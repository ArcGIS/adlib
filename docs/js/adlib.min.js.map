{"version":3,"file":"adlib.js","sources":["../lib/getWithDefault.js","../lib/mapValues.js","../lib/deepMap.js","../lib/optional-transform/arborist.js","../lib/optional-transform/optional.js","../lib/adlib.js"],"sourcesContent":["/**\n * Return the value of a deep property, using a path.\n */\nexport default function getWithDefault (obj, path, defaultValue = undefined) {\n  return path\n    .split('.')\n    .reduce((o, p) => o ? o[p] : defaultValue, obj)\n}\n","/**\n * Simply Map over the props of an object\n */\nexport default function mapValues (obj, fn) {\n  let keys = Object.keys(obj);\n  // console.info(`keys: ${keys}`);\n  var newObject = keys.reduce(function(acc, currentKey) {\n    // console.log(`   acc: ${JSON.stringify(acc)} curKey: ${currentKey}`);\n    acc[currentKey] = fn(obj[currentKey], currentKey, obj);\n    return acc;\n  }, {});\n  // console.info(`  output: ${JSON.stringify(newObject)}`);\n  return newObject;\n}\n","/**\n * Deep Map over the values in an object\n */\nimport mapValues from './mapValues';\n\n function isDate (v) {\n   return v instanceof Date\n }\n\n function isFunction (v) {\n   return typeof v === 'function'\n }\n\n function isObject (v) {\n   return typeof v === 'object'\n }\n\n function isRegExp (v) {\n   return v instanceof RegExp\n }\n\nexport default function deepMapValues(object, callback, propertyPath, that) {\n  propertyPath = propertyPath || '';\n  if(Array.isArray(object)){\n    return object.map(deepMapValuesIteratee);\n  }\n  else if(object && isObject(object) && !isDate(object) && !isRegExp(object) && !isFunction(object)){\n    return Object.assign({}, object, mapValues(object, deepMapValuesIteratee));\n  }\n  else {\n    let output = callback(object, propertyPath);\n    return output;\n  }\n\n  function deepMapValuesIteratee(value, key){\n    var valuePath = propertyPath ? propertyPath + '.' + key : key;\n    return deepMapValues(value, callback, valuePath);\n  }\n}\n","/**\n * The arborist is responsible for pruning trees with nodes/entries\n * marked with `{{delete:NNN}}`\n *\n * There are multiple exports, mainly to allow for easy testing of the\n * worker functions. Only `arborist` is meant to be used directy\n */\n// import mapValues from 'lodash.mapvalues';\nimport mapValues from '../mapValues';\n\nfunction isObject (v) {\n  return typeof v === 'object'\n}\n\n/**\n * Trim a tree decorated with `{{delete:NNN}}`\n */\nexport function arborist (object, propertyPath) {\n  propertyPath = propertyPath || '';\n\n  if(Array.isArray(object)){\n    // filter out any nulls...\n    let arrResults = object.map(iteratee).filter((entry) => {\n      // need to ensure entry is actually NULL vs just falsey\n      return entry !== null && entry !== undefined;\n    });\n    return pruneArray(arrResults);\n\n  } if(object && isObject(object) ) {\n\n    return pruneObject(mapValues(object, iteratee));\n\n  } else {\n\n    return getPropertyValue(object, propertyPath);\n  }\n\n  function iteratee(value, key){\n    var valuePath = propertyPath ? propertyPath + '.' + key: key;\n    return arborist(value, valuePath);\n  }\n}\n\n/**\n * Prune an array\n * For all the entries in the array...\n *    if the entry is a naked string and contains `{{delete:NNN}}`\n *      get maximum NNN value\n *    then\n *      if maxN === 0\n *        return an empty array\n *      if maxN > 0\n *        return `{{delete:maxN-1}}`\n *    else\n *      return array\n */\nexport function pruneArray (arrResults) {\n  let res = arrResults;\n  // is any entry a string w/ {{delete}}?\n  let maxLevel = arrResults.reduce((maxLevel, e) => {\n    if (isString(e) && hasDelete(e)) {\n      let lvl = getLevel(e);\n      if (lvl > maxLevel) {\n        maxLevel = lvl;\n      }\n    }\n    return maxLevel;\n  }, -1);\n\n  if (maxLevel > -1) {\n    if (maxLevel === 0) {\n      res = []\n    } else {\n      res = `{{delete:${maxLevel - 1}}}`;\n    }\n  }\n\n  return res;\n}\n\n\nexport function pruneObject (objResults) {\n  // console.log(`   pruneObject:: working on ${JSON.stringify(objResults)}`);\n  let startVal = {obj: {}, maxLevel: -1 };\n  let res;\n  // cook a new clone object, and track the maxLevel\n  let reduction = Object.keys(objResults).reduce((acc, key) => {\n    let val = objResults[key];\n    if (isString(val) && hasDelete(val)) {\n      let lvl = getLevel(val);\n      if (lvl > acc.maxLevel) {\n        acc.maxLevel = lvl;\n      }\n    } else {\n      // only add the prop if it's not a `{{delete:NNN}}`\n      acc.obj[key] = val;\n    }\n    return acc;\n  }, startVal);\n  // if -1, we return entire object...\n  // if 0 we just remove the prop...\n  // if 1 we return undefined...\n  // if > 1 we return the deleteVal\n  if (reduction.maxLevel > 0 ) {\n    if (reduction.maxLevel === 1) {\n      res = undefined;\n    } else {\n      res = `{{delete:${reduction.maxLevel - 1}}}`;\n    }\n  } else {\n    res = reduction.obj;\n  }\n\n  // console.log(`     returning ${JSON.stringify(res)}`);\n  return res;\n}\n\n/**\n * Get a value for a property, handling the `{{delete:NNN}}` syntax\n */\nexport function getPropertyValue (val){\n  let output = val;\n\n  if (typeof val === 'string') {\n    if (hasDelete(val)) {\n      output = getDeleteValue(val);\n    }\n  }\n  return output;\n}\n\n/**\n * Given a string with `{{delete:NNN}}`\n * if NNN === 0 return undefined\n * else return `{{delete:NNN - 1}}`\n */\nfunction getDeleteValue (val) {\n  let output = val;\n  let level = getLevel(val);\n  if (level === 0) {\n    output = undefined;\n  } else {\n    output = `{{delete:${level}}}`;\n  }\n  return output;\n}\n\n/**\n * Extract the level from a `{{delete:NNN}}`\n */\nfunction getLevel (value) {\n  return parseInt(value.replace(/{|}/g, '').split(':')[1]);\n}\n\n/**\n * Simple check if a value has `{{delete` in it\n */\nfunction hasDelete (value) {\n  if (value && typeof value === 'string') {\n    return value.indexOf('{{delete') > -1;\n  } else {\n    return false;\n  }\n}\n\nfunction isString (v) {\n  return typeof v === 'string';\n}\n","/**\n * Optional Transform\n * Supports a declarative syntax for optional template properties\n *\n * {{some.object.key:optional:2}}\n *\n * In this example, if defined, the value of `some.object.key` is used.\n * If not defined, then the optional transform is utilized\n * and a post-processing step is executed which will remove two parent levels\n * from the output structure\n */\n\nexport default function optional(key, value, settings, level = 0) {\n  // console.log(`optional: ${key}, ${value}, ${level}`);\n  let val = value;\n  if (!value) {\n    val = `{{delete:${level}}}`;\n  }\n  return val;\n}\n","/**\n * adlib.js\n */\nimport getWithDefault from './getWithDefault';\nimport deepMapValues from './deepMap';\nimport {arborist} from './optional-transform/arborist';\nimport optionalTransform from './optional-transform/optional';\n\nfunction isString(v) {\n  return typeof v === 'string';\n}\n\nfunction _swap(parameter, settings, transforms) {\n  let value;\n  // Parameters can optionally call transform functions\n  // e.g. \"{{ipsum:translateLatin}}\"\n  // so extract {{<parameter>:<transformFunction>:<key||value>}}\n  let transformCheck = parameter.split(':');\n  if (transformCheck.length > 1) {\n    // we have a request to use a transform...\n    let key = transformCheck[0];\n    let fn = transformCheck[1];\n    // we default to using the value...\n    let param = null;\n    if (transformCheck[2]){\n      param = transformCheck[2];\n    }\n    if(transforms && transforms[fn] && typeof transforms[fn] === 'function') {\n      // get the value from the param\n      value = getWithDefault(settings, key);\n      // transform it...\n      value = transforms[fn](key, value, settings, param);\n    } else {\n      throw new Error(`Attempted to apply non-existant transform ${fn} on ${key} with params ${param}`);\n    }\n  } else {\n    // we just get the value\n    value = getWithDefault(settings, parameter);\n  }\n  return value;\n}\n\n// Combine a Template with Settings\nexport default function adlib(template, settings, transforms = null) {\n  transforms = transforms || {};\n  if (transforms.optional) {\n    throw new Error('Please do not pass in an `optional` transform, adlib provides that interally.');\n  } else {\n    transforms.optional = optionalTransform;\n  }\n\n  let res = deepMapValues(template, function(templateValue, templatePath){\n    // Only string templates\n    if (!isString(templateValue)) {\n      return templateValue;\n    }\n\n    // When we match \"{{layer.fields..}}\"\n    var settingsValue;\n    var replaceValue = false;\n    var handlebars = /{{([\\w\\.\\:(||)?]+)}}/g;\n    let match = templateValue.match(handlebars);\n\n    if (match && match.length) {\n      let values = match.map((entry) => {\n        let path = entry.replace(/{|}/g, '');\n        // checking if there were multiple paths specified\n        // If so, take the value of the path that matches first\n        // in order from left to right.\n        //\n        // e.g.\n        //\n        // {{special.value||backup.value}}\n        //\n        // we will prefer the value @ 'special.value' but if it is not\n        // there we will take the value @ 'backup.value'\n        if (path.indexOf('||') !== -1) {\n          var paths = path.split('||');\n          path = paths.find((pathOption) => {\n            let v = getWithDefault(settings, pathOption.split(':')[0], null)\n            return v !== null && v !== undefined\n          })\n        }\n\n        return {\n          key: entry,\n          value: _swap(path, settings, transforms)|| entry\n        };\n      });\n      values.forEach((v) => {\n        if (templateValue == v.key) {\n          settingsValue = v.value;\n        } else {\n          // a little extra regex dance to match the '||' because '|'\n          // is a Very Special Regex Character and we need to super\n          // escape them for the regex to work\n          let re = new RegExp(v.key.replace(/\\|\\|/gi, '\\\\|\\\\|'));\n          templateValue = templateValue.replace(re, v.value);\n        }\n      });\n\n      // if we have a value, let's return that...\n      if (settingsValue) {\n        return settingsValue;\n      } else {\n        // but if we don't, lets return the template itself\n        return templateValue;\n      }\n    } else {\n      // no match, return the templateValue...\n      return templateValue;\n    }\n  });\n  return arborist(res);\n}\n"],"names":["getWithDefault","obj","path","defaultValue","undefined","split","reduce","o","p","mapValues","fn","Object","keys","acc","currentKey","isDate","v","Date","isFunction","isObject","isRegExp","RegExp","deepMapValues","object","callback","propertyPath","that","deepMapValuesIteratee","value","key","Array","isArray","map","assign","arborist","iteratee","pruneArray","filter","entry","pruneObject","getPropertyValue","arrResults","let","res","maxLevel","e","isString","hasDelete","lvl","getLevel","objResults","startVal","reduction","val","output","getDeleteValue","level","parseInt","replace","indexOf","optional","settings","_swap","parameter","transforms","transformCheck","length","param","Error","adlib","template","optionalTransform","templateValue","templatePath","settingsValue","handlebars","match","find","pathOption","forEach","re"],"mappings":"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"}